############################################### Pandas Series ###########################################
list_data=['2019-07-02', 3.14, 'ABC', 100, True]
sr=pd.Series(list_data, index=list('abcde'))
idx=sr.index
val=sr.values
print(sr[3])

tp_data=('hwooks',96, 46, '남', '1978.01.18',True)
sr=pd.Series(tp_data, index=['name','학번', '나이','성별', '생년월일','bool'])
### index에 특정 string을 설정하더라도 numerical indexing도 여전히 가능
print(sr['성별'])
print(sr[[3,4]])             ## 복수개의 indexing; 일반 리스트에서는 지원 X, 
print(S1[['b','d']])         ## 시리즈에서 위치 기반 인덱싱을 사용해서 여러 요소를 선택 가능
print(sr[1:5]) 
SR1.name='population'
SR1.index.name='state'

SR1.Califonia=np.nan ##np.nan은 NaN(부동소수점으로 취급) 결과를 반환하는 반면, None은 TypeError를 반환
null_mask = SR1.isnull()  ## 각 요소에 대해 True, Faulse로 반환
filled_series=SR1.fillna(0) 
SR1.isnull().sum()
dropped_series=SR1.dropna()

##### type 변경
list_from_series=s2.tolist()
dict_from_series=s2.to_dict()
df_from_series=s2.to_frame(name='value')



############################################### DataFrame ############################################### 
data = np.random.randint(100,120,size=(3,3))
df = pd.DataFrame(data,index=['d1','d2','d3'],columns=['pd','sales','inv'])
#### indexing 
#### integer location / label location [3, 'name'] 이렇게 섞어서는 error
#### 애초에 index 자체를 number로 assign하고 loc[i,'']는 가능
print(df.iloc[0,1])
iloc[0:2,0:2]
data = {'A': [1, 2, 3, 4], 'B': [5, 6, 7, 8], 'C': [9, 10, 11, 12]}
df = pd.DataFrame(data,index=['a','b','c','d'])
print(df.loc['a','B'])
# 인덱스 'a부터 'b' ,'' 'A'부터 'B'선택
print(df.loc['a':'b','A':'B'])
print(df.iloc[1],'\n') # [1] 하나만 있으면 행을 가리키는것  행,열
print(df.loc['d2']) # -> index 이름이 d2인것
rint(df.iloc[1,:],'\n') # 행은 1이고 열은 전부다
print(df.loc['d2',:]) # 행은 d2이고 열은 전부다

### iloc은 integer indexing만, loc은 labe indexing만 가능 섞어서 쓰는건 안됨.
### 단 열 컬럼을 숫자로 만들어놓으면 상관없음.
#################################### concatenate
id=np.arange(1,1001)
i1=pd.Series(id)
gender = np.random.randint(2,size=1000)
g1=pd.Series(gender)
age=np.random.randint(1,101,size=1000)
a1=pd.Series(age)
region=np.random.randint(1,11,size=1000)
r1=pd.Series(region)

df=pd.concat([i1, g1,a1,r1], axis=1)  ### 열 방향으로 쌓는다 (컬럼이 추가)
### pd.concat([i1, g1,a1,r1], axis=0)  ### 행 방향으로 쌓는다 (행이 추가)
### inplace=True ==> 원본에 반영할 건지.. True는 반영
df.rename(columns={0:'id', 1:'gender', 2:'age', 3:'region'}, inplace=True)
#################################### drop
df.drop(['gender'], axis=1, inplace=True) ## axis=1 ==> 열 기준으로... (열을 drop시킬 때)
df.drop([0], axis=0, inplace=True)        ## axis=0 ==> 행 기준으로... (행을 drop시킬때)
#################################### at
df.at[5,'id']  ## <=== df.loc[5,'id']과 기능적으로 동일 but 단일 값을 접근할때는 속도가 빠름
#################################### upate
df.loc[1,'d4']=0
df.loc['d4']=0  ## 행의 모든 값도 업데이트 가능


#################################### is null 계산 None or np.nan
numNull=df.isnull().sum()           ## 이렇게 하면 column별 null 값을 반환
numNull=df.isnull().sum().sum()     ## 두번해야지 전체 df null 값을 반환
numNull=df.iloc[:,0].isnull().sum()           ## 1st column별 null 값을 반환
numNull=df.iloc[0].isnull().sum()           ## 이렇게 하면 1st 열 null 값을 반환
filled_df=df.fillna(0)
#################################### copy
df1=df.copy()  ### df1=df[:] 과는 다름 df.copy는 df1을 수정/업데이트해도 df에 영향이 X 반면,  df1=df[:] df1이 수정되면 df도 함께 수정

#################################### random seed 고정: random gen 시에 고정된 (첫번째 seed: 0) 으로 생성
np.random.seed(0)       
a=np.random.randint(1,5, size=(10,5))

#################################### 2차원 배열을 2차원 list로.. 다시 데이터프레임으로 변환
np.random.seed(0); a=np.random.randint(1,5, size=(10,5)); list1=a.tolist();
df1=pd.DataFrame(list1, columns=['c1', 'c2', 'c3','c4','c5'])

### df를 list로
list1=ar.tolist()
### df를 dict로
dict1=df1.to_dict('list')            ### 'dict', 'series', 'records', 'index'....