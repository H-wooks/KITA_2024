---------------------------------------- TABLE을 휴지통에 버리지 않고 완전히 삭제할 때
DROP TABLE Orders cascade constraints purge;

---------------------------------------- TABLE 생성
CREATE TABLE NEWORDERS (
ORDERID NUMBER,
CUSTID NUMBER NOT NULL,
BOOKID NUMBER NOT NULL,
SALEPRICE NUMBER,
ORDERDATE DATE,
PRIMARY KEY(ORDERID),
FOREIGN KEY(CUSTID) REFERENCES NEWCUSTOMER(CUSTID) ON DELETE CASCADE);

---------------------------------------- TABLE에 DATA VALUE 넣기
INSERT INTO NEWORDERS VALUES (1,1,1,14000, TO_DATE('2024-05-20 14:49:30','YYYY-MM-DD HH24:MI:SS'));
INSERT INTO NEWORDERS VALUES (5,1,6,3000, SYSDATE);

---------------------------------------- 저장하기
COMMIT;

---------------------------------------- 검색하기/중복없이 검색하기
-- 중복 없이 출력 DISTINCT
SELECT PUBLISHER FROM BOOK;
SELECT DISTINCT PUBLISHER FROM BOOK;      

---------------------------------------- 조건으로 검색하기
SELECT * FROM BOOK WHERE  PRICE >= 10000 AND PRICE <= 20000;
SELECT * FROM BOOK WHERE PRICE BETWEEN 10000 AND 20000;
SELECT BOOKNAME, PUBLISHER FROM BOOK WHERE BOOKNAME LIKE '%축구%';
SELECT * FROM BOOK WHERE PUBLISHER IN ('굿스포츠','대한미디어');

-------------------- 정렬
SELECT * FROM BOOK ORDER BY PRICE DESC;
-------------------- 간단한 함수
SELECT SUM(SALEPRICE) AS TOTAL, AVG(SALEPRICE) AS AVERAGE,
MAX(SALEPRICE) AS MAXIMUM, MIN(SALEPRICE) AS MINIMUM
FROM ORDERS;

-------------------- GROUP BY / HAVING 사용 예
-- 도서 수량이 2보다 조건
SELECT CUSTID, COUNT(*) AS 도서수량, SUM(SALEPRICE) AS "총 판매액"
FROM ORDERS
WHERE BOOKID > 5 GROUP BY CUSTID
HAVING COUNT(*) > 2;

---------------------------------------- INNER JOIN 사용
SELECT C.NAME, B.BOOKNAME, O.SALEPRICE
FROM CUSTOMER C 
INNER JOIN ORDERS O ON C.CUSTID = O.CUSTID
INNER JOIN BOOK B ON O.BOOKID = B.BOOKID
WHERE O.SALEPRICE = 20000;

---------------------------------------- OUTER JOIN  (LEFT) 사용
-- OPTION 1 USING JOIN
-- LEFT가 기준이 되므로 LEFT (처음 테이블)의 모든 행은 나오는 JOIN형태 (없으면 NULL로...)
SELECT C.NAME, B.BOOKNAME, O.SALEPRICE
FROM CUSTOMER C
LEFT OUTER JOIN ORDERS O ON C.CUSTID=O.CUSTID
LEFT OUTER JOIN BOOK B ON B.BOOKID=O.BOOKID
ORDER BY C.NAME;

-- OPTION 2 USING WHERE
-- 기준이 되는 반대 TABLE에 (+)를 표시해서 없더라도 더 추가해서 NULL로라도 표기함
SELECT C.NAME,B.BOOKNAME, O.SALEPRICE
FROM CUSTOMER C, BOOK B, ORDERS O
WHERE C.CUSTID=O.CUSTID(+)
AND B.BOOKID(+) = O.BOOKID
ORDER BY C.NAME;

---------------------------------------- FOREIGN KEY
-- NEWORDERS에 CUSTID를 NEWCUSTOMER 테이블의 CUSTID 키를 REFERENCE로 해서 FOREIGN 키로 설정하면,
-- 부모인 NEWCUSTOMER 테이블의 CUSTID와 관련된 DATA가 삭제되면 NEWORDERS에서도 삭제
CREATE TABLE NEWORDERS (
~
FOREIGN KEY(CUSTID) REFERENCES NEWCUSTOMER(CUSTID) ON DELETE CASCADE);
test) 
-- NEWCUSTOMER에서 PRIMARY KEY인 CUSTID=1인 DATA를 삭제를 하면 NEWORDERS에서 CUSTID=1에 해당하는 ORDERS DATA도 모두 삭제..
DELETE FROM NEWCUSTOMER WHERE CUSTID=1;
-- NEWORDERS에서 CUSTID=3인 DATA를 삭제 하면 NEWORDERS에서는 삭제되지만, NEWCUSTOMER에서 CUSTID=3인 DATA들은 삭제 x.. 그대로 존재..
DELETE FROM NEWORDERS WHERE CUSTID=1;
-- NEWORDERS에서 CUSTID 컬럼을 삭제하더라도 NEWCUSTOMER에서는 삭제 안되고 그대로 남아 있음
ALTER TABLE NEWORDERS DROP COLUMN CUSTID;
-- 반면, NEWCUSTOMER에서는 CUSTID 컬럼은 NEWORDERS에서 FOREIGN 키로 설정되어 있어서 아예 삭제가 안됨
-- 다만, NEWORDERS에서 FOREIGN 키로 설정되어 있던  CUSTID를 먼저 DROP시키고 나서 NEWCOSTOMER에서 CUSTID COLUMN을 DROP으로 삭제는 가능
ALTER TABLE NEWCUSTOMER DROP COLUMN CUSTID;

---------------------------------------- SUB QUERY (부속 질의) 추가 예정

---------------------------------------- UPDATE 추가 예정
UPDATE CUSTOMER SET ADDRESS='대한민국 대전' WHERE NAME='박세리';
UPDATE CUSTOMER SET ADDRESS=(SELECT ADDRESS FROM CUSTOMER WHERE NAME='김연아') WHERE NAME='박세리';

---------------------------------------- LETTER 추출
-- SUBSTR(원본문자열 혹은 컬럼, 시작위치, 추출개수)
SELECT 성, COUNT(성) FROM (SELECT NAME, SUBSTR(NAME, 1, 1) as 성 FROM CUSTOMER) GROUP BY 성;

---------------------------------------- REPLACE 추가 예정
UPDATE BOOK SET BOOKNAME=REPLACE(BOOKNAME,'야구','농구');

---------------------------------------- 시간 추출 

